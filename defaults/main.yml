---
tftp_http_proxy_url: "https://artifactory.asig.cisco.com:443/artifactory/tftp-http-proxy/tftp-http-proxy"
tftp_http_proxy_checksum: "sha256:7be2ac36fdc0b10995dae4355aec9f6ad5d84af7d80b1fb73bf7716e0b4de511"
tftp_http_proxy_systemd_service: |
  [Unit]
  Description=tftp-http-proxy
  After=syslog.target

  [Service]
  User=nobody
  Group=nogroup
  AmbientCapabilities=CAP_NET_BIND_SERVICE
  ExecStart=/usr/local/bin/tftp-http-proxy -http-base-url http://localhost/tftp/ -http-append-path
  Restart=always
  KillSignal=SIGQUIT
  Type=simple
  NotifyAccess=all

  [Install]
  WantedBy=multi-user.target

boot_ubuntu_release_default: focal
boot_ubuntu_allowed_releases:
  - focal
  - bionic
boot_ubuntu_cloud_init_image_root_filesystem: "{{ boot_ubuntu_release_default }}-server-cloudimg-amd64-root.tar.xz"
boot_ubuntu_cloud_init_image_root_filesystem_uncompressed: "{{ boot_ubuntu_release_default }}-server-cloudimg-amd64-root.tar"
boot_ubuntu_cloud_image_url: "https://{{ boot_ubuntu_cloud_image_server }}/ubuntu-cloud-images/{{ boot_ubuntu_release_default }}/current/{{ boot_ubuntu_cloud_init_image_root_filesystem }}"
boot_ubuntu_cloud_image_shasum_filename: "SHA256SUMS"
boot_ubuntu_cloud_image_shasum_url: "https://{{ boot_ubuntu_cloud_image_server }}/ubuntu-cloud-images/{{ boot_ubuntu_release_default }}/current/{{ boot_ubuntu_cloud_image_shasum_filename}}"
boot_ubuntu_cloud_image_shasum_signature_filename: "{{ boot_ubuntu_cloud_image_shasum_filename ~ '.gpg' }}"
boot_ubuntu_cloud_image_shasum_signature_url: "https://{{ boot_ubuntu_cloud_image_server }}/ubuntu-cloud-images/{{ boot_ubuntu_release_default }}/current/{{ boot_ubuntu_cloud_image_shasum_signature_filename }}"
boot_ubuntu_cloud_image_gpg_pubkey_local_path: "fetch/common/gpg-pubkeys/D2EB44626FDDC30B513D5BB71A5D6C4C7DB87C81-cdimage@ubuntu.com.gpg"

ipxe_installer_host: "{{ ansible_fqdn }}"
ipxe_cloud_init_host: "{{ ipxe_installer_host }}"
ipxe_console: framebuffer
ipxe_console_serial_dev: ttyS1
ipxe_console_serial_baud: 115200n8
ipxe_base_path: /srv/www/tftp/ipxe
ipxe_installer_path: "/cloud-init-images/${release}/amd64/current"

ipxe_config_files: "{{ ipxe_config_files_default }}"
ipxe_config_files_default:
  main.ipxe:
    path: "{{ ipxe_base_path }}"
    state: present
    content: |
       # So certs are validated properly...
       ntp {{ ipxe_ntp_server_ip }}

       # Send metadata to retrieve custom variables
       chain --autofree meta.ipxe?ip=${ip}&mac=${mac:hexraw}&platform=${platform}&version=${version:uristring}&dns=${dns}&domain=${domain}&product=${product:uristring}&uuid=${uuid} || echo Unable to contact boot server to send metadata

       # Set host FQDN as best as we can
       chain --autofree set-fqdn.ipxe

       # Load the name-specific file, if it exists
       chain --autofree fqdn/${fqdn}.ipxe || echo Unable to load FQDN-specific config

       # Set up default variables
       chain --autofree default-variables.ipxe

       # Now boot
       chain --replace --autofree boot.ipxe

  set-fqdn.ipxe:
    path: "{{ ipxe_base_path }}"
    state: present
    content: |
      # Set a default fully-qualified domain name based on DHCP
      isset ${net0.dhcp/domain} || goto no_domain
      isset ${net0.dhcp/hostname} || goto no_hostname
      set fqdn ${net0.dhcp/hostname}.${net0.dhcp/domain}
      goto fqdn_final
      
      # DHCP did not return a domain
      :no_domain
      echo No domain name found in DHCP
      # Use the just hostname from a reverse DNS lookup if present
      echo Trying reverse DNS
      isset ${rdns-hostname} && goto rdns_hostname_without_dhcp_domain
      echo No reverse DNS found
      # Load the MAC-specific file, should just set fqdn
      # otherwise just use the MAC address as a hostname
      chain --autofree mac/${mac:hexraw}.ipxe || set fqdn host-${mac:hexraw}
      goto fqdn_final
      
      :rdns_hostname_without_dhcp_domain
      set fqdn ${rdns-hostname} && goto fqdn_final
      
      # DHCP did not return a hostname, but it returns a domain name
      :no_hostname
      echo No hostname found in DHCP
      # Use the hostname from a reverse DNS lookup if present
      echo Trying reverse DNS
      isset ${rdns-hostname} && goto rdns_hostname_with_dhcp_domain
      echo No reverse DNS found
      # Load the MAC-specific file, should just set fqdn
      # otherwise just use the MAC address as a hostname
      echo Falling back onto using MAC address
      chain --autofree mac/${mac:hexraw}.ipxe || set fqdn host-${mac:hexraw}.${net0.dhcp/domain}
      goto fqdn_final
      
      :rdns_hostname_with_dhcp_domain
      set fqdn ${rdns-hostname}.${net0.dhcp/domain} && goto fqdn_final
      
      :fqdn_final
      echo Using ${fqdn} as fully qualified domain name

  default-variables.ipxe:
    path: "{{ ipxe_base_path }}"
    state: present
    content: |
      # Ubuntu Linux Release
      isset ${release} || set release {{ boot_ubuntu_release_default }}

      # Console configuration
      isset ${console} || set console {{ ipxe_console }} # serial or framebuffer
      isset ${console-serial-dev} || set console-serial-dev {{ ipxe_console_serial_dev }}
      isset ${console-serial-baud} || set console-serial-baud {{ ipxe_console_serial_baud }}

      iseq ${console} serial && goto console-serial ||
      iseq ${console} framebuffer && goto console-framebuffer || goto console-final
      :console-serial
      isset ${kernel-console} || set kernel-console console=${console-serial-dev},${console-serial-baud} console=tty0
      isset ${installer-cmdline} || set installer-cmdline console=${console-serial-dev},${console-serial-baud}
      goto console-final
      :console-framebuffer
      iseq ${console} framebuffer && isset ${kernel-console} || set kernel-console console=tty0
      iseq ${console} framebuffer && isset ${installer-cmdline} || set installer-cmdline console=tty0
      :console-final

      # Installer
      isset ${installer-path} || set installer-path {{ ipxe_installer_path }}
      isset ${installer-host} || set installer-host {{ ipxe_installer_host }}
      isset ${installer-url} || set installer-url https://${installer-host}${installer-path}

      # Linux
      isset ${linux-image} || set linux-image boot-kernel
      isset ${initrd-image} || set initrd-image boot-initrd
      isset ${initrd-image-url} || set initrd-image-url ${installer-url}/${initrd-image}
      isset ${kernel-image-url} || set kernel-image-url ${installer-url}/${linux-image}

      # Cloud Init
      isset ${cloud-init-host} || set cloud-init-host {{ ipxe_cloud_init_host }}
      isset ${cloud-init-seed-url} || set cloud-init-seed-url https://${cloud-init-host}/cloud-init/${release}/fqdn/${fqdn}/

      # Kernel
      isset ${kernel-root} || set kernel-root root=${installer-url}//squashfs ro overlayroot=tmpfs
      isset ${kernel-initrd} || set kernel-initrd initrd=${initrd-image}
      isset ${kernel-hostname} || set kernel-hostname hostname=${fqdn}
      isset ${kernel-network} || set kernel-network ip=dhcp
      isset ${kernel-cloud-init} || set kernel-cloud-init ds=nocloud-net;h=${fqdn};s=${cloud-init-seed-url};i=${uuid} || echo Unable to contact boot server to send metadata

      isset ${kernel-random} || set kernel-random RAND=${random-token}
      #isset ${kernel-debug} || set kernel-debug debug=y break=top

      isset ${kernel-cmdline} || set kernel-cmdline ${kernel-initrd} ${kernel-root} ${kernel-console} ${kernel-hostname} ${kernel-network} ${kernel-cloud-init} ${kernel-random} ${kernel-debug} --- ${installer-cmdline}

  boot.ipxe:
    path: "{{ ipxe_base_path }}"
    state: present
    content: |
      menu Continuing with iPXE will destroy existing data on the machine!  Continue?
      item --gap Choice:
      item --key y yes Yes, continue and destroy data
      item --key n no No, do not continue and leave data as is
      choose --default no target && goto ${target}

      :yes
      echo Booting ${release}...
      echo kernel ${kernel-image-url} ${kernel-cmdline}
      echo initrd ${initrd-image-url}

      kernel ${kernel-image-url} ${kernel-cmdline}
      initrd ${initrd-image-url}
      boot

      :no
      shell

cloud_init_app_base_path: /var/www/cloud-init

cloud_init_app_requirements: |
  wheel==0.33.6
  Flask==1.1.1
  uwsgi==2.0.18
  py3dns==3.2.1

cloud_init_app_systemd_service: |
  [Unit]
  Description=cloud-init app
  After=syslog.target

  [Service]
  User=www-data
  Group=www-data
  ExecStart=/bin/bash -c 'cd {{ cloud_init_app_base_path }} && source venv/bin/activate && exec uwsgi --master -s /run/cloud-init-app/cloud-init-app.sock --manage-script-name --mount /=cloud-init-app:app --virtualenv {{ cloud_init_app_base_path }}/venv'
  RuntimeDirectory=cloud-init-app
  RuntimeDirectoryMode=0770
  Restart=always
  KillSignal=SIGQUIT
  Type=notify
  NotifyAccess=all

  [Install]
  WantedBy=multi-user.target

cloud_init_app_nginx_site: |
  server {
    listen 80;
    listen [::]:80;
    listen 443 ssl;
    listen [::]:443 ssl ipv6only=on;
    include snippets/ssl.conf;
    error_log syslog:server=unix:/dev/log;
    access_log syslog:server=unix:/dev/log;
    root "{{ cloud_init_www_base_path }}/../";
    server_name _;
    location /cloud-init/ {
      try_files $uri @cloud_init_app;
    }
    location @cloud_init_app {
      include uwsgi_params;
      uwsgi_pass unix:/run/cloud-init-app/cloud-init-app.sock;
    }
    location /cloud-init-images/ {
      autoindex on;
      try_files $uri $uri/ =404;
    }
    location /ipxe/ {
      root "/srv/www/tftp/";
      autoindex on;
      try_files $uri $uri/ @cloud_init_app;
    }
    location /tftp/ {
      autoindex on;
      try_files $uri $uri/ =404;
    }
  }

cloud_init_www_base_path:  /srv/www/cloud-init

cloud_init_config_nocloud_seed_path: /var/lib/cloud/seed/nocloud
cloud_init_config_files: "{{ cloud_init_config_files_default }}"
cloud_init_config_files_default:
  cloud-init.yml:
    path: "{{ cloud_init_www_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: config-jinja
    content: !unsafe |
      #
      # Set up cloud-init
      #
      # This allows one to reconfigure a machine without reinstalling it by running
      # cloud-init clean && cloud-init init.  It's expected that cloud-init is already
      # installed.  There should be no dependencies on the network or boot
      # server and the system will run autonomously.
      #

      # Reject routes to 169.254.169.254/32
      disable_ec2_metadata: true

      write_files:
          # Refer to datasource from now on
        - path: /etc/cloud/cloud.cfg.d/99_ds_nocloud.cfg
          permissions: '0644'
          owner: 'root:root'
          content: |
            #cloud-config
            warnings:
              dsid_missing_source: off
            datasource_list: [ NoCloud ]
            datasource:
              NoCloud: {}

      runcmd:
        - rm /etc/cloud/cloud.cfg.d/90_dpkg.cfg

  curtin.yml:
    path: "{{ cloud_init_www_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: config-jinja
    content: |
      write_files:
        - path: /etc/curtin/curtin.conf
          permissions: '0600'
          owner: root:root
          content: |
            #curtin-config

            # Copy resultant system, set up by cloud-init
            sources:
              - cp:///
      
            # Device where we install.  curtin doesn't like paths in /dev/disk for
            # block-meta simple installs
            block-meta:
              devices: {% raw %}{{ ds.meta_data.curtin.block_meta.devices }}{% endraw %}

            grub:
              # Keep serial console configs
              terminal: unmodified
              # Always boots from PXE otherwise
              reorder_uefi: False

            early_commands: {}

            partitioning_commands: {}

            network_commands: {}

            late_commands:
              # Remove residue from overlayfs root
              00_cmd: [ curtin, in-target, '--', rmdir, /media/root-ro ]
              01_cmd: [ curtin, in-target, '--', rmdir, /media/root-rw ]

              # Remove residue configs from curtin
              02_cmd: [ curtin, in-target, '--', /bin/bash, -c, 'rm -rf /etc/update-motd.d/60-unminimize /etc/apt/sources.list.curtin.old /etc/cloud/cloud.cfg.d/50-curtin-networking.cfg' ]

              # Remove initramfs hooks and utils used to boot over the network
              04_cmd: [ curtin, in-target, '--', bash, -c, 'rm /usr/share/initramfs-tools/hooks/{wget,addentropy,certs} /usr/local/bin/rndaddentropy' ]

              # Remove curtin
              06_cmd: [ curtin, in-target, '--', apt, remove, curtin, -y, --purge ]
              07_cmd: [ curtin, in-target, '--', rm, -rf, /etc/curtin ]
              08_cmd: [ curtin, in-target, '--', rm, "/var/lib/cloud/scripts/per-once/{99}curtin.sh" ]

              # Remove extraneous dependencies from packages removed earlier
              90_cmd: [ curtin, in-target, '--', apt, autoremove, --purge, -y ]
              91_cmd: [ curtin, in-target, '--', apt, clean ]
      
        # Goofy naming with braces is because we have to run after runcmd, 
        # and scripts are sorted in lexical order
        - path: "/var/lib/cloud/scripts/per-once/{99}curtin.sh"
          permissions: '0700'
          owner: root:root
          content: |
            #!/bin/bash
            set -e
            set -x
            DEFAULT_ESP_DEVICE="{% raw %}{{ ds.meta_data.curtin.block_meta.devices | first }}{% endraw %}15"
            if [ -d /sys/firmware/efi/efivars ]; then
              FIRMWARE=efi
            else
              FIRMWARE=bios
            fi
            CURTIN_ARGS="-c /etc/curtin/curtin.conf"
            # HACK cmm - Apply ESP already mounted workaround for grub-multi-install
            if [[ "$FIRMWARE" = "efi" ]]; then
              CURTIN_ARGS+=" --set grub/install_devices=${DEFAULT_ESP_DEVICE}"
            fi
            CURTIN_ARGS+=" install"
            if ( cloud-init status && curtin ${CURTIN_ARGS} ); then
              touch /run/ci-reboot-required
            else
              logger "Curtin install or cloud-init has failed, not requesting a reboot."
            fi

      power_state:
        delay: now
        mode: reboot
        message: Requested a reboot
        condition: "bash -c 'test -e /run/ci-reboot-required && cloud-init status'"

  network.yml:
    path: "{{ cloud_init_www_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: config-jinja
    content: !unsafe |
      #
      # Set up networking
      #
      # This config overrides cloud-init default networking with networking
      # configuration provided in instance metadata.  For configurations
      # we need with rules are too complex for cloud-init or curtin, we
      # set netplan up manually.
      #
      manage_etc_hosts: true

      # Custom network configuration, otherwise just let cloud-init do it
      {% if ds.meta_data.network | length > 0 %}
      write_files:
      {% for interface in ds.meta_data.network %}
        - path: /etc/netplan/{{ interface.name }}.yaml
          permissions: '0644'
          owner: 'root:root'
          content: |
      {{ interface.content | indent(6, first=True, blank=True) }}
      {% endfor %}
          # Re-install the box if networking has to change, otherwise leave it alone
        - path: /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg
          permissions: '0644'
          owner: 'root:root'
          content: |
            preserve_hostname: true
            network:
              version: 1
              config: disabled

      runcmd:
        - rm /etc/netplan/50-cloud-init.yaml
      {% endif %}

  package.yml:
    path: "{{ cloud_init_www_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: config-seed
    content: |
      package_update: true
      package_upgrade: true
      apt_mirror: https://{{ apt_mirror }}/ubuntu
      apt_preserve_sources_list: false
      apt_mirror_search_dns: false

      bootcmd:
        - "cloud-init-per once -- ping -c 3 {{ apt_mirror }}"

  users.yml:
    path: "{{ cloud_init_www_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: config-seed
    content: |

      # HACK cmm - for troubleshooting purposes only!
      #write_files:
      #  - path: /etc/sudoers.d/01-passwdless-sudo
      #    content: |
      #      # Allow members of group sudo to execute any command and not require a
      #      # password.  Not a good practice for prod FIXME
      #      %sudo ALL=(ALL) NOPASSWD:ALL

      users:
      {% for admin_user_name,admin_user_value in asig_effective_local_admin_users.items() %}
      {% if admin_user_value.state == 'present' %}
        - name: {{ admin_user_value.local_username }}
          gecos: {{ admin_user_value.local_username }}
          primary_group: {{ admin_user_value.local_username }}
          shell: {{ admin_user_value.shell }}
          groups:
            - users
            - sudo
            - adm
          lock_passwd: false
          passwd: "{{ admin_user_value.password_hash }}"
          ssh_authorized_keys:
      {% for ssh_public_key in admin_user_value.ssh_public_keys %}
      {% if ssh_public_key.state == 'present' %}
            - "{{ ssh_public_key.key }}"
      {% endif %}
      {% endfor %}
      {% endif %}
      {% endfor %}

cloud_init_image_root_certificate_query: "[?name == '{{ asig_root_ca_name }}'].certificate | [0]"
cloud_init_image_root_ca_cert: "{{ asig_certificates | json_query(cloud_init_image_root_certificate_query) }}"

cloud_init_image_builder_base_path: "/home/builder/cloud-init-images"

cloud_init_image_builder_files: "{{ cloud_init_image_builder_files_default }}"
cloud_init_image_builder_files_default:
  Dockerfile:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    mode: '0640'
    content: |
      FROM scratch
      WORKDIR /
      ADD {{ boot_ubuntu_cloud_init_image_root_filesystem_uncompressed }} /
      # Files we don't want to include in the squashfs image
      ADD excludes /excludes
      # Include full wget binary in initramfs which supports TLS
      ADD wget /usr/share/initramfs-tools/hooks/wget
      # Root CA certificate
      ADD root-ca.crt /usr/local/share/ca-certificates/root-ca.crt
      # Update CA certificates so the image has the root by default
      RUN update-ca-certificates
      # Add root CA certificate hook to initramfs image
      ADD certs /usr/share/initramfs-tools/hooks/certs
      # Add rndaddentropy binary to initramfs image
      ADD rndaddentropy /usr/local/bin/rndaddentropy
      # Add addentropy hook to initramfs image
      ADD addentropy /usr/share/initramfs-tools/hooks/addentropy
      # Patch rooturl initramfs script to permit https links
      ADD rooturl.patch /rooturl.patch
      # Fix apt to use local mirror with https
      RUN sed -e 's^http://archive\.ubuntu\.com^https://{{ boot_ubuntu_apt_server }}^g' \
              -e 's^http://security\.ubuntu\.com^https://{{ boot_ubuntu_apt_server }}^g' \
              -i /etc/apt/sources.list
      RUN env DEBIAN_FRONTEND=noninteractive \
          apt-get update --quiet && \
          apt-get upgrade --assume-yes --quiet && \
          apt-get autoremove --assume-yes --purge --quiet && \
          # eatmydata speeds things up a bit
          apt-get install --assume-yes --quiet eatmydata && \
          # Remove Canonical cruft
          eatmydata -- apt-get remove --purge --assume-yes --quiet \
             snapd lxcfs lxd lxd-client pollinate && \ 
          # Calm grub installer since we're installing in a container
          echo "grub-pc grub-pc/install_devices_empty boolean true" | debconf-set-selections && \
          # Don't install dumpcap setuid root
          echo "wireshark-common wireshark-common/install-setuid boolean false" | debconf-set-selections && \
          # Don't look for a resume image, speeds up booting
          echo "RESUME=none" > /etc/initramfs-tools/conf.d/resume && \
          #
          # cloud-initramfs-rooturl is the magic package that makes this 
          # possible.  Limit packages to only those required to install
          # and troubleshoot as this causes the squashfs image to grow
          # and requires more memory on the VM.  Let cloud-init take care
          # of the rest.
          #
          eatmydata -- apt-get install --assume-yes --quiet \
             -o Dpkg::Options::="--force-confdef" \
             -o Dpkg::Options::="--force-confold" \
             cloud-initramfs-rooturl && \
          # Patch the rooturl script to use /bin/wget instead of wget,
          # so we don't invoke busybox and instead pick up the full wget
          # and gain https support
          # https://git.busybox.net/busybox/tree/docs/nofork_noexec.txt?h=1_24_stable
          #
          patch -p0 < /rooturl.patch && \
          eatmydata -- apt-get install --assume-yes --quiet \
             -o Dpkg::Options::="--force-confdef" \
             -o Dpkg::Options::="--force-confold" \
             {% if boot_ubuntu_release_default == 'bionic' %}
             linux-signed-generic \
             {% elif boot_ubuntu_release_default == 'focal' %}
             linux-image-generic \
             {% endif %}
             zsh squashfs-tools rsync lshw curtin netplan.io \
             dns-root-data ebtables tshark uidmap && \
          # Allow grub installer to install when curtin runs
          echo "grub-pc grub-pc/install_devices_empty boolean false" | debconf-set-selections && \
          # Clean up local apt package files
          apt-get autoremove --purge --assume-yes && apt-get clean
      # Make a nice debian package manifest list 
      RUN dpkg-query -W -f='${binary:Package}\t${Version}\n' > /squashfs.manifest
      # Finally package it all up into a squashfs image
      RUN mksquashfs / rootfs.xz -comp xz -wildcards -ef excludes && exit 0
      CMD /bin/bash

  excludes:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    mode: '0640'
    content: |
      rootfs.xz
      squashfs.manifest
      .dockerenv
      rooturl.patch
      excludes
      proc/*
      sys/*
      tmp/*
      var/cache/*
      var/log/*
      run/*

  build.sh:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: script
    mode: '0770'
    content: |
      {% set base_dir = (cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default ~ '/') %}
      set -e
      cd $(dirname "$0")

      LOCK_FILE="/tmp/cloud-init-image-builder.lock"
      TEMP_DIR=$(mktemp -d)
      TODAYS_DATE=$(date +"%Y%m%d")
      TARGET_PATH="/srv/www/cloud-init-images/{{ boot_ubuntu_release_default | quote }}/amd64/${TODAYS_DATE}"

      cleanup() {
          # TODO cmm - clean up based on build phase so artifacts are left when errors happen
          debug "Cleaning up..."
          #exit -1
          rm -rf $TEMP_DIR 2> /dev/null
          rm {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem) | quote }} 2> /dev/null || true
          rm {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem_uncompressed) | quote }} 2> /dev/null || true
          rm {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_filename) | quote }} 2> /dev/null || true
          rm {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_signature_filename) | quote }} 2> /dev/null || true
          if [[ "$DOCKER_BUILD_FAILED" == "0" ]]; then
              # This will clobber all images.  Not expecting to run any other Docker on boot machine
              docker image rm $(docker images -a -q) 2> /dev/null || true
              # if any...
          else
              debug "Docker build failed.  Leaving images in place."
          fi
          # if any...
          kill $(jobs -p) 2> /dev/null || true
          rm -f $LOCK_FILE
      }

      error() {
          logger -t $(basename $0) -s "$(date --rfc-3339=seconds) $1"
          exit 1
      }

      warn() {
          logger -t $(basename $0) -s "$(date --rfc-3339=seconds) $1"
      }

      debug() {
          echo $* 1>&2
      }

      if [[ -f $LOCK_FILE ]]; then
          error "Found ${LOCK_FILE}, exiting..."
      else
          trap cleanup EXIT
          trap cleanup INT
          touch $LOCK_FILE
      fi

      debug "Downloading cloud init root filesystem..."
      curl -s --output {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem) | quote }} {{ (boot_ubuntu_cloud_image_url) | quote }}

      debug "Downloading cloud init hash..."
      curl -s --output {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_filename) | quote }} {{ (boot_ubuntu_cloud_image_shasum_url) | quote }}

      debug "Downloading cloud init hash detached signature..."
      curl -s --output {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_signature_filename) | quote }} {{ boot_ubuntu_cloud_image_shasum_signature_url | quote }}

      debug "Verifying GPG signature of hash"
      gpgv --keyring {{ (base_dir ~ (boot_ubuntu_cloud_image_gpg_pubkey_local_path | basename)) | quote }} {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_signature_filename) | quote }} {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_filename) | quote}}
      if [[ $? -ne 0 ]]; then
        error "GPG did not verify signature correctly"
      fi

      debug "Checking hash against cloud init base image"
      shasum -a 256 -c <(grep {{ boot_ubuntu_cloud_init_image_root_filesystem | quote }} {{ (base_dir ~ boot_ubuntu_cloud_image_shasum_filename) | quote }})
      if [[ $? -ne 0 ]]; then
        error "shasum did not check against image correctly"
      fi

      # Work around docker bug where xz keeps running after build finishes
      debug "Uncompressing root filesystem to a bare tarball"
      xz --decompress --stdout {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem) | quote }} > {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem_uncompressed) | quote }}
      rm {{ (base_dir ~ boot_ubuntu_cloud_init_image_root_filesystem) | quote }}

      debug "Starting docker build..."
      DOCKER_BUILD_FAILED=0
      if ! docker build -t cloud-init-image-{{ boot_ubuntu_release_default }}:latest /home/builder/cloud-init-images/{{ boot_ubuntu_release_default }}/; then
        DOCKER_BUILD_FAILED=1
        error "Docker build failed..."
      fi

      debug "Starting docker container to extract files..."
      DOCKER_CONTAINER_IMAGE=$(docker run -d --rm --name {{ (boot_ubuntu_release_default ~ '-container') | quote }} {{ ('cloud-init-image-' ~ boot_ubuntu_release_default ~ ':latest') | quote }} /bin/bash -c 'sleep infinity')

      debug "Starting to extract files from container..."
      docker export ${DOCKER_CONTAINER_IMAGE} | tar -xf - -C $TEMP_DIR rootfs.xz squashfs.manifest boot/

      debug "Killing docker container..."
      docker kill ${DOCKER_CONTAINER_IMAGE}

      debug "Placing cloud-init-images so they can be served..."
      mkdir -vp $TARGET_PATH
      cp $TEMP_DIR/rootfs.xz ${TARGET_PATH}/squashfs
      cp $TEMP_DIR/squashfs.manifest ${TARGET_PATH}/squashfs.manifest
      {% if boot_ubuntu_release_default == 'bionic' %}
      {# HACK cmm - with bionic unknown kernel version, use glob #}
      cp $TEMP_DIR/boot/vmlinuz* ${TARGET_PATH}/boot-kernel
      cp $TEMP_DIR/boot/initrd* ${TARGET_PATH}/boot-initrd
      {% elif boot_ubuntu_release_default == 'focal' %}
      {# HACK cmm - focal has symlinks, which is nice #}
      cp $TEMP_DIR/boot/vmlinuz ${TARGET_PATH}/boot-kernel
      cp $TEMP_DIR/boot/initrd.img ${TARGET_PATH}/boot-initrd
      {% endif %}
      chmod go+r ${TARGET_PATH}/boot-kernel
      chmod go+r ${TARGET_PATH}/boot-initrd

      debug "Linking cloud-init-images current..."
      rm $(realpath ${TARGET_PATH}/../)/current || true
      ln -s $(basename ${TARGET_PATH}) ${TARGET_PATH}/../current

      debug "Removing cloud-init-images that are more than 60 days old"
      find $(realpath ${TARGET_PATH}/../) -maxdepth 1 ! -path $(realpath ${TARGET_PATH}/../) -mtime +60 -type d -exec rm -rf {} \;
      debug "Success!"

  root-ca.crt:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    mode: '0640'
    content: "{{ cloud_init_image_root_ca_cert }}"

  wget:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: script
    mode: '0550'
    content: |
      set -e
      case $1 in
              prereqs) echo ""; exit 0;;
      esac
      . /usr/share/initramfs-tools/hook-functions
      copy_exec /usr/bin/wget /bin

  addentropy:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: script
    mode: '0550'
    content: |
      set -e
      case $1 in
              prereqs) echo ""; exit 0;;
      esac
      . /usr/share/initramfs-tools/hook-functions
      copy_exec /usr/local/bin/rndaddentropy /bin

  certs:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: script
    mode: '0550'
    content: |
      set -e
      case $1 in
              prereqs) echo ""; exit 0;;
      esac
      . /usr/share/initramfs-tools/hook-functions
      mkdir -p ${DESTDIR}/etc/ssl/certs || true
      cp /usr/local/share/ca-certificates/root-ca.crt ${DESTDIR}/etc/ssl/certs
      c_rehash ${DESTDIR}/etc/ssl/certs

  rooturl.patch:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: present
    type: script
    mode: '0644'
    content: |
      --- /usr/share/initramfs-tools/scripts/local-top/rooturl.bak	2020-01-23 17:47:59.332380112 +0000
      +++ /usr/share/initramfs-tools/scripts/local-top/rooturl	2020-01-23 18:55:36.224247742 +0000
      @@ -42,7 +42,7 @@
       			*.tar.xz|*.txz) zopt="J";;
       		esac
       		debug 1 "# [$zopt] $url"
      -		wget "$url" -O - | tar -C "$target" -xp${zopt}f -
      +		/bin/wget --ca-directory=/etc/ssl/certs "$url" -O - | tar -C "$target" -xp${zopt}f -
       	done
       	[ -x "$target/sbin" ]
       }
      @@ -54,7 +54,7 @@
       		return 1
       	fi
       	debug 1 "mount_squash downloading $url to $target.img"
      -	wget "$url" -O "$target.img"
      +	/bin/wget --ca-directory=/etc/ssl/certs "$url" -O "$target.img"
       	debug 1 "mount -t squashfs -o loop ${ROOTFLAGS}" \
       		"'$target.img' '$target'"
       	mount -t squashfs -o loop ${ROOTFLAGS} \
      @@ -82,12 +82,18 @@
       	"$helper" "$target" "$firsturl" "$@"
       }
      
      +add_entropy() {
      +	 /bin/rndaddentropy
      +}
      +
       . /scripts/functions
      
       case "$ROOT" in
       	http://*|*:http://*) :;;
      +	https://*|*:https://*) :;;
       	*) exit 0
       esac
      +add_entropy
       configure_networking || exit
      
       debug 1 "root=$ROOT"

  multipath.conf:
    path: "{{ cloud_init_image_builder_base_path ~ '/' ~ boot_ubuntu_release_default }}"
    state: absent
...
